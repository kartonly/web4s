#  Токены
Если простыми словами, это замещение объекта каким-то обозначением, что-то, что должен иметь пользователь, чтобы получить доступ к информации, ресурсу. 

## Виды токенов
### Simple Web Token (SWT) 
Это токен, предназныченный для Интернета (HTTP), он может быть отправлен в заголовке аутентификации HTTP. Это пары ключ-значение, закодированные в формате HTML form. Ключи и соответствующие значения оставляются на усмотрение эмитента и проверяющей стороны. Но есть несколько зарезервированных ключей - Issuer, Audience и ExpiresOn и HMACSHA256.
SWT защищен HMAC. HMACSHA256 - последний ключом в токене, а ему соответствующее значение - это SHA 256 HMAC секретный ключ. Эмитент и проверяющая сторона используют секретный 256-битный ключ, который является общим, то есть на обоих концах один и тот же ключ (симметричный ключ).

*SWT - хороший выбор для Web-API ASP.NET.*

Пример:
```
    Issuer=http://auth.myservice.com
    Audience=http://myservice.com
    ExpiresOn=1435937883&
    UserName=John 
    Smith&UserRole=Admin&
    HMACSHA256=KOUQRPSpy64rvT2KnYyQKtFFXUIggnesSpE7ADA4o9w
```

### JSON Web Token (JWT)
Это открытый стандарт для создания токенов доступа, основанный на формате JSON. Как правило, используется для передачи данных для аутентификации в клиент-серверных приложениях. Токены создаются сервером, подписываются секретным ключом и передаются клиенту, который в дальнейшем использует данный токен для подтверждения своей личности. 
Он содержит три блока, разделенных точками: заголовок, набор полей и подпись. Первые два блока представлены в JSON-формате и дополнительно закодированы в формат base64. Набор полей содержит произвольные пары имя/значения. JWT имеет несколько зарезервированных имен - iss, aud, exp и другие. 
Подпись может генерироваться при помощи и симметричных алгоритмов шифрования, и асимметричных. Кроме того, существует отдельный стандарт, отписывающий формат зашифрованного JWT-токена.

*JSON Web Tokens — популярная технология, часто используется для передачи данных для аутентификации в клиент-серверных приложениях.*

Пример:
```
    { «alg»: «HS256», «typ»: «JWT» }.
    { «iss»: «auth.myservice.com», «aud»: «myservice.com», «exp»: «1435937883», «userName»: 
    «John Smith», «userRole»: «Admin» }.
    S9Zs/8/uEGGTVVtLggFTizCsMtwOJnRhjaQ2BMUQhcY
```

### Security Assertion Markup Language (SAML)
Определяет токены (SAML assertions) в XML-формате, включающем информацию об эмитенте, о субъекте, необходимые условия для проверки токена, набор дополнительных утверждений (statements) о пользователе. 
Подпись SAML-токенов осуществляется при помощи ассиметричной криптографии. SAML-токены содержат механизм для подтверждения владения токеном, что позволяет предотвратить перехват токенов.

Стандарт SAML описывает способы взаимодействия и протоколы между identity provider и service provider для обмена данными аутентификации и авторизации посредством токенов. 
Этот основополагающий стандарт — достаточно сложный и поддерживает много различных сценариев интеграции систем. Основные «строительные блоки» стандарта:
1.	Assertions — собственный формат SAML токенов в XML формате.
2.	Protocols — набор поддерживаемых сообщений между участниками.
3.	Bindings — механизмы передачи сообщений через различные транспортные протоколы.
4.	Profiles — типичные сценарии использования стандарта, определяющие набор assertions, protocols и bindings необходимых для их реализации.
***
SAML более похож на SOAP, а SWT и JWT - на REST.
***
*SAML широко используется в облачных приложениях для высокой эффективности, безопасности и масштабируемости доступа пользователей к ним.*

***
## Пример
Для примера я возьму JWT, так как он отвечает нынешним требованиям к безопасности, является сравнительно несложным, а так же имеет огромную популярность и широко распространён в наши дни.

Кодировать будем следующую информацию: имя пользователя, айди пользователя, айди устройства пользователя, выданные роли, дату окончания действия токена, алгоритм шифрования, того кто выдал токен и для кого он предназначен.

>Итак, JWT состоит из трех частей: header, payload (полезная нагрузка, она же набор полей) и signature(подпись).

### header
Хедер содержит информацию о том, как должна вычисляться JWT подпись, а именно алгоритм хеширования и тип токена.
```
    { "alg": "HS256", "typ": "JWT"}
```

### payload
Это полезная нагрузка, которую так же называют claims. Сюда мы кладём информацию, которую передаём
* iss — отправитель.
* aud — получатель.
* exp — время жизни токена.
* userName — имя пользователя.
* userId - id пользователя.
* deviceId - id устройства.
```
    { 
    «iss»: «auth.myservice.com», 
    «aud»: «myservice.com», 
    «exp»: «173538902638», 
    «userName»: «Alex Smith», 
    «userId»: «1»,
    «deviceId»: «2»,
    «userRole»: «Admin» 
    }
```

### signature
Вычисление подписи на основе заголовка и нагрузки происходит с помощью кода.
Сначала header и payload приводятся к формату JSON, а затем переводятся в base64. Далее они соединяются через точку и хэшируются указанным в header алгоритмом. 
```
    const SECRET_KEY = 'secret007'
    const code = base64urlEncode(header) + '.' + base64urlEncode(payload)
    const signature = HMAC-SHA256(code, SECRET_KEY)
```

Затем объединяем всё это воедино:
```
    const token = encodeBase64Url(header) + '.' + encodeBase64Url(payload) + '.' + encodeBase64Url(signature)
```
Результат и будет токеном:
```
    eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJhdXRoLm15c2VydmljZS5jb20iLCJhdWQiOiJteXNlcnZpY2UuY29tIiwiZXhwIjoxNzM1Mzg5MDI2MzgsInVzZXJOYW1lIjoiQWxleCBTbWl0aCIsInVzZXJJZCI6IjEiLCJkZXZpY2VJZCI6IjIiLCJ1c2VyUm9sZSI6IkFkbWluIn0.KSK7xj5034JgVdBRPYhbvDMv9LFd0HhFZQhEhFnwNp0
```

Когда пользователь делает API-запрос с приложенным к нему токеном JWT, сервер декодирует header и payload и проверяет зарезервированные поля. Если все в порядке, по указанному в header алгоритму составляется подпись. Если полученная подпись совпадает с переданной, значит JWT валидный, и пользователь получит доступ к сервису. 

